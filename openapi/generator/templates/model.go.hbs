{{> partials.copyHeader }}

package okta

{{#if (eq model.modelName "UserProfile")}}
type UserProfile map[string]interface{}
{{else}}
{{> model.imports this}}

{{#if (eq model.modelName "Application")}}
type App interface {
	IsApplicationInstance() bool
}

{{/if}}

{{#if (eq model.modelName "Factor")}}
type UserFactor interface {
	IsUserFactorInstance() bool
}

type UserFactors []UserFactor

func (uf *UserFactors) UnmarshalJSON(data []byte) error {
	rawFactors := []json.RawMessage{}
	if err := json.Unmarshal(data, &rawFactors); err != nil {
		return err
	}

	factors := make([]map[string]interface{}, len(rawFactors))
	if err := json.Unmarshal(data, &factors); err != nil {
		return err
	}

	for i, f := range factors {
		var factor UserFactor

		switch ft := f["factorType"]; ft {
		case "call":
			factor = new(CallFactor)
		case "email":
			factor = new(EmailFactor)
		case "push":
			factor = new(PushFactor)
		case "question":
			factor = new(SecurityQuestionFactor)
		case "sms":
			factor = new(SmsFactor)
		case "token":
			factor = new(TokenFactor)
		case "token:hardware":
			factor = new(HardwareFactor)
		case "token:software:totp":
			factor = new(TotpFactor)
		case "u2f":
			factor = new(U2fFactor)
		case "web":
			factor = new(WebFactor)
		default:
			return fmt.Errorf("unknown factor type %q", ft)
		}

		if err := json.Unmarshal(rawFactors[i], factor); err != nil {
			return err
		}

		*uf = append(*uf, factor)
	}

	return nil
}

{{/if}}
{{#if (or (or (gt model.methods.length 0) (gt model.crud.length 0)) (eq model.modelName "LogEvent"))}}
type {{model.modelName}}Resource resource

{{/if}}
{{#if (eq model.modelName "ApplicationSettingsApplication")}}
type {{model.modelName}} map[string]interface{}
{{else}}
type {{model.modelName}} struct {
	{{{buildModelProperties model}}}
}
{{/if}}
{{#if (or ( eq model.tags.[0] "Application" ) ( eq model.tags.[0] "UserFactor") ) }}
func New{{model.modelName}}() *{{model.modelName}} {
	return &{{model.modelName}}{
		{{#each model.properties as |prop|}}
		{{#if (ne prop.default undefined) }}
		{{structProp prop.propertyName}}: "{{prop.default}}",
		{{/if}}
		{{/each}}
		{{#if (ne model.resolution undefined) }}
		{{structProp model.resolution.fieldName}}: "{{model.resolution.fieldValue}}",
		{{/if}}
	}
}

func (a *{{model.modelName}}) Is{{model.tags.[0]}}Instance() bool {
	return true
}

{{/if}}
{{#each operations as |operation|}}
{{> model.defaultMethod  operation=operation modelName=../model.modelName}}
{{/each}}
{{/if}}
